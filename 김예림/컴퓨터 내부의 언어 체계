# 컴퓨터 내부의 언어 체계

컴퓨터는 어떤 말을 사용할까?

---

언어란 무엇인가?

모든 언어의 뜻은 기호의 집합으로 인코딩된다. 하지만 의미를 기호로 인코딩하는 것만으로는 충분하지 않다.

언어가 제대로 작동하려면 의사소통하는 당사자들이 모두 같은 문맥을 공유해서 같은 기호에 같은 뜻을 부여할 수 있어야 한다. 하지만 언제나 문맥을 명확히 식별할 수 있는 것은 아니다. 컴퓨터 언어에도 마찬가지 문제가 있다.

문자 언어

문자 언어는 기호를 나열한 것이다.

기호나 조합은 무궁무진한 가능성이 있다. 언어마다 순서도 다를 수 있다.

비트

먼저 상자에 대해 생각해보자. 자연어에선, 이 상자를 문자라고 부르고 컴퓨터에서는 비트라고 부른다. 

비트라는 단어는 2진법을 사용한다는 뜻의 binary와 숫자를 뜻하는 digit가 기묘하게 합쳐진 말이다.

비트는 2진법을 사용한다. 

논리연산

다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 이런 동작을 논리 연산이라고 한다.

드모르간의 법칙

a And b라는 연산은 NOT(NOT a OR NOT a)와 같다고 말한다.

지금까지 살펴본 긍정적인 논리에 더해 부정적인 논리를 기술하는 명제를 사용할 때 드모르간의 법칙을 활용할 수 있다. 

정수를 비트로 표현하는 방법

수는 논리보다 더 복잡하지만 단어보다는 훨씬 단순하다.

- 양의 정수 표현
10진수 체계에서는 10가지 기호인 숫자를 상자에 담을 수 있다. 이때 오른쪽에서 왼쪽으로 상자가 쌓여가며, 각 상자마다 각기 다른 이름이 붙어 있다. 비트를 사용해 값을 만들 때도 이와 비슷하게 접근할 수 있다. 10진 숫자 대신 비트를 사용하기 때문에 각 상자에 사용할 수 있는 기호는 1과 0 두가지 밖에 없다.
2진수 체계는 10을 밑으로 하지 않고 2를 밑으로 하는 수 체계다.
10진수로는 5,028이 네 자리 숫자라고 말할 수 있따. 2진수로는 5,028이 13비트 수가 된다.
2진수에서 가장 오른쪽의 비트를 가장 작은 유효 비트라고 부르고, 가장 왼쪽의 비트를 가장 큰 유효비트라고 부른다.
- 이진수 덧셈
두 비트를 서로 더한 결과는 두 비트를 XOR 한 값과 같고, 올림은 두 비트를 AND 한 값과 같다.
한 연산에서 두 비트만 더하는 경우는 드물다. 
덧셈 결과가 우리가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어나면 오브플로가 발생한다. 오버플로란 말은 MSB에서 올림이 발생했다는 뜻이다. 컴퓨터에는 조건 코드 레지스터라는 것이 있어서 몇 가지 이상한 정보를 담아둔다. 이런 정보 중에는 오버플로 비트가 있고, 이 비트에는 MSB에서 발생한 올림값이 들어간다. 
이 비트값을 보면 오버플로가 발생했는지 알 수 있다. MSB 위쪽에서 1을 빌려오는 경우를 언더플로라고 부른다.
- 음수 표현
앞 절에서 살펴본 모든 2진수는 양수였다. 하지만 실제 세계에서 문제를 해결하려면 양수와 음수를 모두 사용해야 하는 경우가 많다. 4비트로 수를 16가지만 표현할 수 있다는 말이 꼭 4비트로는 0부터 15까지만 표현할 수 있다는 뜻은 아니다. 언어는 문맥과 의미를 통해 작용한다. 이 말은 비트들을 해석하는 새로운 문맥을 만들 수 있다는 뜻이기도 하다.

- 부호와 크기 
음수와 양수를 구별하기 위해 흔히 부호를 사용한다. 한 비트를 부호에 사용하고 나머지 비트를 수의 크기, 즉 0부터의 거리를 표현하기 위해 사용하는 이런 방법을 부호와 크기 표현법이라고 말한다. 
부호와 크기 표현법은 두 가지 이유로 인해 널리 쓰이지 못하고 있다.
1. 비트들을 구성하려면 비용이 드는데 0을 표현하는 방법이 두 가지라서 비용이 낭비된다. (양수 0과 음수 0)
2. 부호와 크기 표현법을 사용하면 XOR과 AND를 통한 덧셈 계산을 사용할 수가 없다.

- 1의 보수
음수를 표현하는 또 다른 방법으로는 양수의 모든 비트를 뒤집는 방법이 있다. 이런 방법을 1의 보수 표현법이라고 부른다. 1의 보수 표현법에서도 부호와 크기 표현법과 비슷하게 비트들을 부호 비트와 나머지로 나눈다. 1의 보수라는 문맥에서는 NOT 연산을 통해 보수를 얻는다.
1의 보수 표현법에도 0을 두 가지 방식으로 표현한다는 문제가 여전히 존재한다. 게다가 1의 보수에서도 덧셈을 쉽게 할 수는 없다. 이 문제를 해결하려면 MSB 쪽에서 올림이 발생한 경우에는 LSB로 올림을 전달해야 하는데, 이를 순환 올림이라고 부른다. 현대 컴퓨터에서는 부호와 크기 표현법이나 1의 보수 표현법을 모두 사용하지 않는다. 이 두 방식을 사용한 계산은 추가적인 하드웨어 없이는 제대로 작동할 수 없고, 하드웨어를 추가해야 한다는 말은 비용이 더 든다는 뜻이다.

- 2의 보수
특별한 하드웨어를 추가할 수 없고 XOR과 AND 연산만 사용해야 한다면 어떻게 일반 정수 사이의 덧셈을 할 수 있을까? 4비트 수의 경우 +1은 0001이다. 1111을 0001에 더하면 0000이 된다. 이런 표현법을 2의 보수 표현법이라고 하며, 이 방법은 부호가 있는 정수를 표현할 때 가장 널리 쓰이는 방법이다. 어떤 수의 비트를 뒤집고(즉 각 비트의 NOT를 취하고) 1을 추가하면 음수를 얻을 수 있다. 이때 MSB에서 올림이 발생하면 이 값은 버린다. +1, 즉 0001의 비트를 뒤집으면 1110이고, 여기에 1을 더하면 1111이 되며, 이 값이 -1을 표현한다. 비트 개수가 커지면 표현할 수 있는 값의 범위가 지수적으로 증가한다. 같은 숫자로 이뤄진 수를 보더라도 문맥에 따라 표현하는 값이 달라질 수 있다는 점을 꼭 염두에 둬야 한다.

실수를 표현하는 방법

밑이 10인 실수에는 10진 소수점이 포함된다. 따라서 밑이 2인 경우, 실수를 표기하기 위해 2진 소수점을 표현할 방법이 필요하다. 여기서도 정수의 경우와 마찬가지로 문맥에 따라 실수를 표현하는 방법이 달라질 수 있다.

- 고정 소수점 표현법
2진수를 사용해 소수를 표현하기 위해 2진 소수점의 위치를 임의로 정하는 방법이 있다. 예를 들어, 4비트가 있다면 그 중 2비트는 2진 소수점의 오른쪽에 있는 분수들을 표현하는 데 쓰고 2비트는 왼쪽에 있는 숫자들을 표현하는 데 쓸 수 있다. 소수점의 위치가 항상 일정하기 때문에 이런 방식을 고정소수점 표현법이라고 부른다. 정수와 비슷하게 소수점 왼쪽의 2비트는 네 가지 정수를 표현한다. 2진 소수점 오른쪽에 있는 숫자들은 10진 소수점의 오른쪽에 있는 숫자들과 비슷하게 분수를 표현한다. 다만 2진 수의경우에는 1/10, 1/100 등 10의 거듭제곱을 분모로 사용하는 10진 소수와 달리, 1/2, 1/4 등 2의 거듭제곱을 분모로 사용한다는 점이 다를 뿐이다. 
이런 접근 방법이 잘 작동하기는 하지만, 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트 개수가 너무 많기 때문에 범용 컴퓨터에서 이런 방식을 사용하는 경우는 드물다. 디지털 신호 처리 장치 등 특별한 목적에 쓰이는 일부 컴퓨터는 여전히 고정 소수점 수를 쓰기도 한다.
범용 컴퓨터는 일반적인 문제를 해결하기 위해 만들어진 컴퓨터라서 그렇게 불린다.
- 부동 소수점 표현법
플랑크 상수부터 아보가드로 수에 이르는 범위의 값을 2진수로 표현한다는 문제를 해결하기 위해, 과학적 표기법을 2진수에 적용한다. 과학적 표기법은 수를 해석하는 새로운 방법을 도입해서 큰 범위의 수를 표현한다. 과학적 표기법에서는 10진 소수점 왼쪽이 한 자리뿐인 소수에 10을 몇 번 거듭제곱한 값을 곱하는 방식으로 소수를 표현한다. 이런 표현법을 부동소수점 표현법이라고 부르는 이유가 헷갈릴 수도 있다.
부동소수점 표현법은 지수와 가수를 분리함으로써 수를 표현할 때 필요한 0을 모두 저장하지 않고도 큰 수나 작은 수를 표현할 수 있다.
- IEEE 부동소수점 수 표준
지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있다. 다만 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있다. 그리고 낭비되는 비트 조합을 최소화하고 반올림을 쉽게 하기 위한 여러 가지 트릭이 사용된다.
똑같은 비트를 사용하더라도 정밀도를 가능한 한 높이고 싶다. 한 가지 트릭은 정규화다. 정규화는 가수를 조정해서 맨 앞에 0이 없게 만드는 것이다. 이런 식으로 가수를 조정하려면 지수도 조정해야 한다. 두 번째 트릭은 디지털 이큅먼트 사에서 고안한 것으로, 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략하는 것이다. IEEE 754의 세부 사항을 모두 알 필요는 없지만 두 가지 부동소수점 수가 자주 쓰인다는 사실을 알아둬야 한다. 한 가지는 기본 정밀도 부동소수점 수이고, 다른 한가지는 2배 정밀도 부동소수점 수다.

2진수를 다루는 쉬운 방법

- 8진 표현법
8진 표현법은 2진수 비트들을 3개씩 그룹으로 묶는 아이디어다.
- 16진 표현법
16진 표현법이 쓰이는 이유는 요즘 컴퓨터 내부가 8비트의 배수를 사용해 만들어지기 때문이다.
- 프로그래밍 언어의 진법 표기법
여러 프로그래밍언어에서는 다음과 같은 표기법을 따른다.
- 0으로 시작하는 숫자는 8진 숫자다. 예를 들어, 017은 8진수이며 값은 10진수로 15다.
- 1부터 9까지의 숫자로 시작하는 숫자는 10진수다. 예를 들어 123은 10진수다.
- 0x가 앞에 붙은 숫자는 16진수다. 예를 들어 0x12f는 16진수이며 값은 10진수 303이다.

비트 그룹의 이름

컴퓨터는 제대로 조직화되지 않은 비트들로 이뤄지지 않는다. 컴퓨터를 설계하는 사람은 비용을 고려해 컴퓨터가 사용할 비트의 개수와 비트들의 조직을 결정해야만 한다. 수 표현과 마찬가지로 비트의 개수와 조직에 대해서도 다양한 아이디어를 시험해봤지만 그중 일부만 살아남았다.

비트는 너무 작아서 기본 단위로 사용하기에는 유용성이 떨어진다. 세계적으로 8비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 이를 바이트라고 부른다.

워드는 각 컴퓨터가 설계상 자연스럽게 사용할 수 있는 비트 묶음의 크기를 가리키는 말로 쓰인다. 자연스럽게 쓸 수 있다는 말은 컴퓨터가 빠르게 처리할 수 있다는 가장 큰 덩어리를 뜻한다. 

텍스트 표현

컴퓨터는 항상 비트를 다룬다는 사실과 비트를 사용해 수와 같은 대상을 표현할 수 있다는 사실을 알았다. 다음 단계로 넘어가서 수를 사용해 문자나 키보드에 있는 다른 기호 등을 표현하는 방법을 살펴보자.

- 아스키 코드
수와 마찬가지로 텍스트를 표현하는 방법의 경우에도 몇 가지 아이디어가 서로 경쟁했다. 아스키 코드 표에서 몇 가지의 재미있는 코드들은 글자를 출력하는 데 쓰이지 않고 장치는 제어하기 위해 쓰이기 때문에 제어 문자라고 불린다.
- 다른 표준의 진화
아스키는 영어를 표현하는 데 필요한 모든 문자를 표함하고 있어서 상당 기간 표준 역할을 했다. 초기 컴퓨터는 대부분 미국산이었고, 미국산이 아닌 컴퓨터는 영국산이었다. 하지만 컴퓨터가 널리 쓰이게 됨에 따라 그 밖의 언어를 지원해야 할 필요가 점차 늘어났다.
- 유니코드 변환 방식 8비트
인코딩은 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴을 뜻한다. 미국 컴퓨터과학자 켄 톰슨과 캐나다 프로그래머 롭 파이크가 만든 유니코드 변환 형식 8비트라는 인코딩 방법이 하위 호환성과 효율성 때문에 가장 널리 쓰이고 있다. UTF-8은 모든 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩 할 때는 추가 공간이 필요하지 않다. 그리고 UTF-8은 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩한다. UTF-8은 문자를 8비트 덩어리(옥텟)의 시쿠너스로 인코딩한다.

문자를 사용한 수 표현

UTF-8은 문자를 표현하는 비트들을 표현하는 숫자들을 표현하기 위해 숫자들을 사용한다.

- 출력 가능하게 변경한 인코딩
퀴티드 프린터블 인코딩, QP 인코딩이라고 하는데 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법이다. QP 인코딩은 전자우편 첨부를 처리하기 위해 만들어졌다. QP 인코딩은 몇 가지의 추가 규칙을 사용한다. 줄의 맨 끝에 탭과 공백 문자가 온다면, 이를 각각 =09와 =20으로 표현해야만 한다. 인코딩된 데이터는 한 줄이 76자를 넘을 수 없다. 만약 어떤 줄의 맨 뒤가 =으로 끝나면 가짜 줄바꿈을 뜻하며, 수신 쪽에서 QP로 인코딩된 데이터를 디코딩할 때는 이 =를 제거하고 해석한다.
- 베이스 64 인코딩
베이스 인코딩이 훨씬 더 효율적이다. QP 인코딩은 잘 작동하기는 하지만 1바이트를 표현하기 위해 3바이트를 사용하기 때문에 아주 비효율적이다. 지금보다 컴퓨터 사이의 통신 속도가 훨씬 느렸던 과거에는 이런 효율성이 정말 중요했다. 베이스64 인코딩은 3바이트 데이터를 4문자로 표현한다. 이 인코딩은 모든 3바이트 조합을 4바이트 조합으로 변환할 수 있지만 원본 데이터 길이가 3바이트의 배수라는 보장은 없다.

패딩 문자를 도입해 이런 문제를 해결한다. 원본 데이터가 2바이트 남으면 끝에 =를 붙이고, 1바이트 남으면 끝에 ==를 붙인다. 이 인코딩 방식은 여전히 전자우편 첨부파일 전송에 많이 사용중이다.
- url 인코딩
웹 페이지의 URL 표현에도 이와 거의 같은 방식을 사용한다. URL 인코딩은 퍼센트 인코딩이라고도 부르는데, %뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩한다.

색을 표현하는 방법

빛을 혼합해 색을 표현하는 방식을 가산색 시스템이라고 부른다. 

- 투명도 추가
여러 다른 알파값의 색을 합성해 새로운 색을 만들어내는 방법을 정의하는 일련의 합성 계산법 식이 있다.
- 색 인코딩
웹 페이지는 주로 사람이 읽을 수 있는 UTF-8문자의 시퀀스로 이뤄지는 텍스트를 표현하기 때문에, 텍스트를 사용해 색을 표현할 방법이 필요하다. 
URL 인코딩과 비슷한 방법으로 색을 인코딩한다. 웹에서는 색을 16진 트리플렛으로 표현한다.
