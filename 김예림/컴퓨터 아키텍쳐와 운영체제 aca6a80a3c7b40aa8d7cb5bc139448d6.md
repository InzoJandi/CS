# 컴퓨터 아키텍쳐와 운영체제

컴퓨터 아키텍쳐라는 말은 컴퓨터의 여러 구성요소를 배치하는 방법을 뜻한다.

멀티태스킹은 여러 프로그램을 동시에 실행하는 기능이거나 최소한 겉으로 보기에는 여러 프로그램이 동시에 실행되는 것처럼 보이게 하는 기능을 뜻한다.

여러 프로그램을 실행한다는 말은 프로그램들의 실행을 제어하기 위한 감독 프로그램인 운영체제가 있어야 한다는 사실을 암시한다.

### 프로세서 코어

1980년대에 처음 만들어진 멀티프로세서 시스템은 단일 CPU보다 훨씬 더 좋은 성능을 얻어내기 위한 방법이다. 하지만 성능을 더 높이는 게 그렇게 쉽지는 않음이 드러났다. 여러 CPU를 활용할 수 있도록 프로그램을 병렬화하는 문제는 아주 많은 수학 계산이 필요한 몇몇 경우에는 잘 작동하지만 일반적인 경우에는 풀 수 없는 문제다. 

### 마이크로프로세서와 마이크로 컴퓨터

메모리와 I/O가 프로세서 코어와 같은 패키지에 들어 있지 않으면 이런 프로세서를 마이크로 프로세서라고 부른다. 반면 모든 요소를 한 칩 안에 패키징하면 마이크로컴퓨터라고 부른다.

마이크로 컴퓨터가 가리키는 대상을 마이크로 컨트롤러라는 용어로 부르기도 하고, 마이크로 컴퓨터를 마이크로 프로세서를 중심으로 만들어진 컴퓨터 시스템을 뜻하는 말로 사용하는 사람도 있다.

마이크로 프로세서는 보통 큰 시스템에 들어가는 부품으로 쓰이고, 마이크로 컴퓨터는 식기세척기 등에서 찾을 수 있는 작은 컴퓨터다.

### 프로시저, 서브루틴, 함수

중복된 코드를 줄이면 코드가 메모리를 덜 차지하고, 코드에 버그가 있는 경우 여러 군데를 반복해 고치지 않고 한 군데만 고치면 된다는 장점이 있다.

함수(프로시저나 서브루틴)는 코드를 재사용하는 주요 수단이다.

프로세서에는 링크 레지스터를 사용해 분기하는 명령어가 있다.

이 명령어는 함수로 호출하는 명령어와 현재 명령어의 다음 위치를 저장하는 명령어를 하나로 합친 것이다.

### 스택

함수가 자기 자신을 호출하는 경우를 재귀라고 한다.

컴퓨터 매니아드리 트리라고 부르고 수학에서 유향 비순환 그래프라고 부르는 이 구조는 화살표를 따라가면서 읽는다.

이 구조에서 화살표는 더 위쪽을 가리킬 수 없기 때문에 순환이 없다.

화살표가 뻗어나가지 않는 부분을 잎노드라고 부르며, 잎노드도 트리의 맨 마지막에 달려있다.

각 노드에서 가지가 4개 뻗어나가는 트리는 쿼드트리라고 부른다. 쿼드트리는 공간 데이터 구조에 속한다.

트리 아래로 내려갈 수 있으면 항상 아래로 내려가고, 더이상 아래로 내려갈 화살표가 없는 경우에만 옆에 있는 화살표로 넘어간다. 이런 방식을 깊이 우선 순회라고 말한다. 

한편 연ㅍ에 있는 화살표를 먼저 방문하고 그 후 아래쪽으로 가는 화살표를 방문하는 방식을 너비 우선 순회라고 말한다.

스택은 LIFO 구조이다. 스택에 물건을 푸시해 넣고 스택에서 물건을 팝해서 제거한다. 스택에 물건을 푸시할 때 더이상 들어갈 공간이 없으면 스택 오버플로, 빈 스택에서 물건을 가져오려고 하는 경우를 스택 언더플로라고 부른다.

스택은 단지 반환 주소만 저장하기 위한 장소는 아니다.

함수가 호출될 때마다 스택에 저장되는 데이터의 모음을 스택 프레임이라고 부른다.

포스나 포스트스크립트 같은 몇몇 언어와 옛날 HP 계산기 몇 가지는 스택 기반 언어다.

### 인터럽트

폴링은 어느정도 잘 작동하지만 아주 잘 작동하지는 않는다.

요즘 쓰이는 프로세서 대부분은 인터럽트 시스템이 들어간다. 인터럽트 시스템은 적절한 신호가 들어오면 CPU 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함한다. 핀은 칩에 연결된 전기적 접점을 뜻하는 말이다.

많은 프로세서 칩에는 통합 주변장치가 들어있고 이런 장치들은 내부적으로 인터럽트 시스템이 연결되어 있다.

CPU가 주의를 기울어야하는 주변 장치는 인터럽트 요청을 생성한다. 프로세서는 현재 실행 중인 명령어를 끝까지 실행한다. 그 후 프로세서는 현재 실행 중인 프로그램을 잠시 중단시키고 인터럽트 핸들러라는 전혀 다른 프로그램을 실행하기 시작한다.

인터럽트 핸들러가 필요한 작업을 다 마치고 나면 원래 실행 중이던 프로그램이 중단된 위치부터 다시 실행을 계속한다. 인터럽트 핸들러는 함수다.

인터럽트 시스템은 서비스 후 돌아올 프로그램 위치는 스택에 저장한다. 인터럽트 핸들러는 자신이 덮어쓸 레지스터를 모두 저장해야할 책임이 있다.

컴퓨터가 어떻게 인터럽트 핸들러 위치를 찾을 수 있을까? 보통은 인터럽트 핸들러 주소를 저장하기로 약속한 메모리 주소가 존재한다. 이 주소에는 여러 인터럽트 벡터가 들어있고, 각 인터럽트 벡터는 단지 메모리 위치를 가리키는 포인터일 뿐이다.

인터럽트를 중단시킬 수 있는 마스크가 있는 경우가 자주 있다. 인터럽트가 많이 있는 기계에는 종종 인터럽트 간의 우선순위가 있어서 더 중요한 인터럽트를 더 먼저 처리하게 해준다. 대부분의 기계에는 일정 시간이 지나면 인터럽트를 발생시킬 수 잇는 내장 타이머도 하나 이상 들어있다.

### 상대 주소 지정

여러 프로그램을 동시에 실행하려면 어떻게 해야할까?

우선 각 프로그램을 서로 전환시켜주는 일종의 관리 프로그램이 필요하다. 이런 프로그램을 운영체제 또는 운영체제 커널이라고 부른다.

os와 os가 관리하는 프로그램을 구분하기 위해 os를 시스템 프로그램이라고 부르고 다른 모든 프로그램을 사용자 프로그램이나 프로세스라고 부른다.

사용자 프로그램의 실행 시간을 조절하는 스케줄링 기법을 시분할이라고 부른다.

사용자 프로그램 상태 또는 문맥은 레지스터의 상태와 프로그램이 사용중인 메모리의 상태를 뜻한다. 이때 메모리에는 스택도 포함된다.

어떤 컴퓨터들은 이런 문제를 인덱스 레지스터를 추가해 해결한다. 인덱스 레지스터의 값을 명령어에 들어있는 주소와 더해서 유효 주소를 계산한다.

상대주소 지정은 명령어에 들어있는 주소를 0부터 시작하는 위치로 해석하지 않고 명령어의 주소를 기준으로 하는 상대적인 주소로 해석한다.

상대주소 지정을 사용하면 프로그램을 메모리의 원하는 위치로 자유롭게 재배치할 수 있다.

### 메모리 관리 장치

이제는 모든 것이 인터넷에 연결되어 있고, 통신 작업은 계속해서 백그라운드에서 실행돼야 하기 때문에 멀티태스킹이 필수다. 

오늘날 대부분의 마이크로프로세서에는 메모리 관리 장치(MMU)가 들어있다. MMU는 아주 복잡한 하드웨어다.

MMU가 들어있는 시스템은 가상주소와 물리주소를 구분한다. MMU는 가상 주소를 물리 주소로 변환해준다. MMU와 인덱스 레지스터는 어떤 차이가 있을까? MMU는 가상 메모리 주소를 두 부분으로 나눈다. 주소의 하위 (LSB 쪽)부분은 물리적 주소 범위와 같다. 상위 (MSB 쪽)부분은 페이지 테이블이라는 RAM 영역을 통해 주소를 변환한다.

물론 모든 내용이 페이지 경계 안에 들어 있어야 한다. 프로그램들이 서로 혀볅하는 경우에는 여러 프로그램의 가상 메모리 중 일부가 같은 물리 메모리를 함께 사용하는 공유 메모리 기능을 제공할 수도 있다.

현대적 프로세서의 MMU는 페이지 테이블 크기가 정해져 있다. 전체 페이지 테이블 항목은 주 메모리에 저장되거나 주 메모리가 부족한 경우 디스크에 저장된다. MMU는 페이지 테이블 항목 중 일부를 필요할 때만 자신의 페이지 테이블로 읽어 들인다. 일부 MMU 설계는 페이지 테이블에 제어 비트를 추가 제공한다. 이런 제어 비트의 예로 실행 불가 비트를 들 수 있다. 어떤 페이지에 대해 실행 불가 비트가 설정되어 있으면 CPU가 이 페이지에 있는 명령어를 실행할 수 없다. 따라서 프로그램이 실수로 자기 데이터를 실행하는 경우를 방지할 수 있다. 데이터 부분을 실행할 수 있으면(프로그램을 실행 시점에 마음대로 바꿔 쓸 수 있기 때문에) 보안 문제가 생길 수도 있다. 또 다른 일반적인 제어 비트로는 페이지를 읽기 전용으로 만드는 비트가 있다.

프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 페이지 폴트 예외가 발생한다. 이런 동작은 스택 오버플로 등이 일어날 때 유용하게 쓰일 수 있다. 스택 오버플로가 발생함녀 스택 범위를 벗어나는 주소에 접근하므로 페이지 폴트가 발생하고, 이 예외가 발생하면 OS는 실행 중인 프로그램을 중단시키는 대신 MMU가 추가 메모리를 할당하게 해서 스택 공간을 늘리고 사용자 프로그램 실행을 계속할 수 있다.

MMU로 인해 폰 노이만 구조와 하버드 구조의 구분이 의미 없어졌다. 단일 메모리 버스만 사용하는 폰 노이만 구조의 시스템도 명령어 메모리와 데이터 메모리를 분리해 제공할 수 있다.

### 가상 메모리

운영체제는 희소한 하드웨어 자원을 사용하려고 경합하는 프로그램들 사이의 자원 분배를 관리한다. OS는 MMU를 사용해 사용자 프로그램에게 가상 메모리를 제공한다.

요청받은 메모리가 사용 가능한(물리적) 메모리의 크기보다 크면 어떻게 될까? OS는 현재 필요하지 않은 메모리 페이지를 더 느리지만 더 용량이 큰 대용량 저장장치인 디스크로 옮긴다(이를 스왑 아웃이라고 부른다). 이런 스왑 아웃한 페이지에 프로그램이 접근하면 운영체제는 필요한 메모리 공간을 확보하고 요청받은 페이지를 다시 메모리로 불러들인다(이렇게 디스크에서 메모리로 페이지를 읽어오는 동작을 스왑 인이라고 부른다). 이런 식으로 페이지를 처리하는 것을 요구불 페이징이라고 부른다.

스와핑(스왑인이나 스왑아웃)이 일어나면 시스템 성능이 크게 저하된다. 메모리가 부족해서 프로그램을 실행도 못 하는 것보다는 느리더라도 스와핑을 통해 프로그램을 실행하는 편이 더 낫다. 가상 메모리 시스템은 성능 저하를 막기 위해 다양한 기법을 활용한다. 이런 기법 중 하나는 페이지 접근을 추적해서 스왑 아웃할 페이지를 결정하는 최소 최근 사용 알고리즘이다. 이 알고리즘을 사용하면 최근에 가장 자주 사용된 페이지는 물리 메모리에 그대로 남겨두고 최근에 가장 덜 사용한 페이지를 스왑 아웃 한다.

### 시스템 공간과 사용자 공간

멀티태스킹 시스템은 모든 프로그램에게 자신이 컴퓨터 안에서 실행되는 유일한 프로그램이라는 환상을 심어준다. MMU는 각 프로세스에게 자신만의 메모리 주소 공간을 제공해서 이런 환상을 키워준다. 하지만 I/O 장치가 끼어들면 이런 환상을 유지하기가 힘들어진다.

운영 체제는 초당 발생할 인터럽트 횟수에 맞춰 타이머를 설정한다. 마찬가지로 사용자 프로그램이 MMU의 설정을 마음대로 바꿀 수 있다면 MMU가 프로그램을 서로 격리시키지 못할 것이다. 여러 CPU는 이런 문자를 해결할 수 있는 추가 하드웨어를 제공한다. CPU에는 컴퓨터가 시스템모드에 있는지 사용자 모드에 있는지 결정하는 비트가 어떤 레지스터 안에 들어있다. I/O를 처리하는 명령어 등 일부 명령어는 특권 명령어라서 오직 시스템모드에서만 실행할 수 있다. 트랩이나 시스템 콜이라고 부르는 특별한 명령어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램(운영체제)에게 요청을 보낼 수 있다.

이런 방식에는 몇 가지 장점이 있다.

1. 이 방식은 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램을 다른 사용자 프로그램으로부터 보호한다.
2. 사용자 프로그램이 MMU 등의 몇몇 요소에 손을 댈 수 없기 때문에 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어할 수 있다. 하드웨어 예외는 오직 시스템 공간에서만 처리된다.

### 메모리 계층과 성능

CPU가 더더욱 빨라졌지만 메모리는 그렇게까지 빨라지지는 못해서 CPU보다 속도가 뒤처지기 시작했다. 컴퓨터 구조를 설계하는 이들은 빠른 CPU가 느린 메모리를 기다리느라고 아무 일도 하지 않는 경우를 줄이기 위해 온갖 방법을 다 쓰기 시작했다. 가상 메모리와 스와핑은 메모리 계층이라는 개념을 소개했다. 사용자 프로그램에게는 모든 메모리가 같아 보이지만 메모리 시스템 내부에서 일어나는 일은 시스템 성능에 큰 영향을 끼친다.

프로세서는 보통 RAM으로 이뤄진 주 메모리와 통신하는데, 주 메모리는 프로세서보다 1/10정도 밖에 속도가 나지 않는다. 디스크 드라이브 등의 대량 저장장치는 프로세서보다 백만 배 느릴 수도 있다.

CPU가 주 메모리보다 10배 더 빠르게 작동한다고 하자. CPU가 메모리를 기다리느라 많은 시간을 소비해야 한다는 뜻이다. 이를 해결하기 위해 캐시라는 하드웨어를 CPU에 추가한다.

CPU 메모리 컨트롤러 하드웨어는 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져온다. 대부분은 연속된 위치에 있는 데이터가 필요하기 때문이다. 메모리에 접근하는 패턴이 순차적이 아니어서 캐시 실패가 일어나도 CPU는 고속 메모리 접근 모드가 가능하기 때문에 좀 더 유리하다. 캐시 실패는 CPU가 캐시에서 어떤 내용을 찾았는데 캐시에 그 데이터가 없어서 메모리를 읽어야 하는 경우를 뜻한다. 비슷하게 캐시 적중은 CPU가 원하는 내용을 캐시에서 찾은 경우를 뜻한다. 캐시 메모리에도 몇 가지 계층이 있다. 모든 캐시가 같은 칩 안에 존재하는 경우에도  CPU에서 멀어질수록 캐시는 더 느려지고 더 커진다. 이들을 L1, L2, L3 캐시라고 부른다. 기계에는 올바른 데이터를 메모리에서 프리페치해서 캐시를 준비시키기 위해 조건 분기 명령어의 결과를 예측하는 분기 예측 회로가 포함된다. 심지어 순서를 벗어나는 실행을 처리하는 회로도 존재한다. 이 회로는 CPU가 프로그램에 명시된 명령어 순서를 벗어나서 가장 효율적으로 명령어를 수행하게 해준다.

캐시 일관성을 유지하는 것은 아주 어려운 문제다. 프로세서 칩이 2개인 컴퓨터를 상상해보라. 각 칩에는 코어가 4개 있다. 코어 중 하나는 데이터를 어떤 메모리 위치에 기록한다. 물론 실제로는 캐시에 데이터가 먼저 기록되며, 결국에는 메모리에도 기록된다. 이 데이터를 사용해야 하는 다른 코어나 프로세서가 해당 메모리 위치의 데이터가 변경됐음을 어떻게 알 수 있을까? 가장 간단한 접근은 라이트 스루다. 이 방법은 데이터를 캐시에 기록하는 동시에 메모리에도 기록한다.

### 코프로세서

프로세서 코어는 아주 복잡한 회로로 이뤄졌다. 몇 가지 연산을 코프로세서라는 더 단순한 회로에 위임하면 프로세서 코어가 일반적인 연산에 활용할 수 있는 공간을 더 확보할 수 있다. 과거에는 한 칩 안에 모든 연산 회로를 넣기 어려웠기 때문에 코프로세서가 쓰였다.

주 메모리와 디스크 사이에 단순한 데이터 복사가 자주 일어날 수 있다는 뜻이다. 일부 코프로세서는 다른 일은 처리하지 않고 데이터 복사만 담당한다. 이런 복사를 직접 메모리 접근이라고 한다. ‘여기서 이만틈의 데이터를 저쪽으로 복사하고, 다 끝나면 나한테 알려줘’와 같은 방식으로 DMA를 설정할 수 있다. CPU는 DMA 장치에 귀찮은 일을 많이 떠맡기기 때문에 유용한 연산을 더 많이 처리할 수 있다. 

### 메모리상의 데이터 배치

메모리에 명령어만 담는 게 아니라 데이터도 담는다는 사실을 알았다. 이 경우 데이터는 정적 데이터다. ‘정적’이라는 말은 프로그램을 작성할 때 얼마나 많은 메모리가 필요한지 알고 있다는 뜻이다. 

프로그램이 메모리를 사용하는 방법이 한 가지 더 있다. 대부분의 프로그램은 동적 데이터를 다뤄야 한다. 동적 데이터는 프로그램을 실행하기 전에는 크기를 알 수 없는 데이터를 말한다. 동적 데이터는 주로 정적 데이터가 차지하는 영역의 바로 위 영역에 쌓이며, 이를 힙이라고 부른다. 더 많은 데이터를 저장해야 할 경우 스택은 아래로 자라나는 반면, 힙은 위로 자라난다. 힙과 스택이 서로 충돌하지 않게 하는 것이 중요하다.

### 프로그램 실행

함수가 필요한 프로그램은 아주 많다. 매번 새로운 함수를 작성하는 대신 누군가 이미 작성한 함수를 활용할 수 있으면 편하다. 이런 편의를 달성하는 한 가지 방법은 관련 함수를 한데 모아서 라이브러리로 만드는 것이다. 문자열 처리부터 복잡한 수학 계산이나 MP3 인코딩에 이르는 다양한 라이브러리가 존재한다.

본격적인 프로그램은 라이브러리뿐 아니라, 여러 조각으로 이뤄진다. 프로그램 전부를 한 파일에 저장할 수도 있지만, 이를 여러 파일로 나눠놓는 편이 더 좋은 이유가 있다. 가장 큰 장점은 여러 사람이 한 프로그램의 여러 부분을 동시에 개발할 수 있다는 점이다.

하지만, 프로그램을 여러 조각으로 나누면 이 모든 조각을 하나로 엮거나 연결할 방법이 필요하다. 각 프로그램을 링크하기 편한 형식의 매개 파일로 나누고, 링커라는 특별한 프로그램을 사용해 여러 조각을 하나로 연결해 실행한다. 과거 다양한 매개 파일 형식이 생겨났다. 실행과 링크가 가능한 형식은 현재 가장 유명한 매개 파일 형식이다. 

링커는 이런 모든 광고를 서로 해소해서 실제로 실행할 수 있는 프로그램을 만들어내는 프로그램이다. 성능을 높이기 위해 훨씬 더 복잡한 방식을 사용한다. 과거에는 라이브러리를 단지 여러분에게 필요한 함수가 들어 있는 파일로 간주해서 프로그램의 나머지 부분과 직접 연결해 실행 파일을 만들었다. 이런 방식을 정적 링크라고 한다.

라이브러리가 여러 프로그램에 쓰인다는 말은 이 라이브러리가 아주 쓸모 있다는 뜻이지만, 정적 링크를 사용하면 같은 라이브러리 코드가 여러 실행 파일에 반복적으로 들어가서 귀중한 메모리를 낭비한다. 그래서 멀틱스 프로그래머들은 공유 라이브러리를 사용하는 동적 링크를 발명했다.

프로그램에는 진입점이 있다. 진입점은 프로그램의 첫 번째 명령어가 위치한 주소를 뜻한다.

프로그램을 이루는 모든 부분이 하나로 합쳐져서 실행파일을 이룰 때 런타임 라이브러리가 추가된다. 실제로는 이 런타임 라이브러리에 있는 명령어가 먼저 실행되고 나중에 진입점의 명령어가 실행된다.

런타임 라이브러리는 메모리 설정을 책임진다. 이 말은 런타임 라이브러리가 스택과 힙 영역을 설정한다는 뜻이다. 런타임 라이브러리는 정적 데이터에 위치한 데이터의 초깃값도 설정한다.

이런 값들은 실행 파일에 들어 있고, 시스템에서 메모리를 할당받은 직후 실행 파일에서 메모리로 복사돼야 한다.

런타임 라이브러리는 더 많은 기능을 수행한다. 특히 언어가 복잡해지면 런타임 라이브러리 기능도 더 복잡해진다.

### 메모리 전력 소비

데이터를 메모리에서 이리저리 옮기면 전력이 소비된다.