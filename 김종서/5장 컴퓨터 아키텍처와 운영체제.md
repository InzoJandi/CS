컴퓨터 아키텍처라는 말은 컴퓨터의 여러 구성요소를 배치하는 방법을 뜻한다.

메모리와 관련한 구조 개선을 다룬다. 명령어 집합 설계, 다른 유형의 레지스터들, 전력 관리, 멋진 실행 장치 같은 구조도 살펴본다. 멀티태스킹은 여러 프로그램이 동시에 실행되는 것처럼 보이게 하는 기능을 뜻하는데, 이 말은 프로그램들의 실행을 제어하기 위한 감독 프로그램인 운영체제가 있어야 한다는 사실을 암시한다.

## 기본적인 구조 요소들

흔한 두 가지 컴퓨터 구조는 폰 노이만 구조와 하버드 구조다. 두 구조의 차이는 메모리 배열뿐이다. 나머지가 모두 같다면 메모리에서 동시에 명령어와 데이터를 가져올 수 없기 때문에 폰 노이만 구조가 약간 더 느리다. 하버드 구조는 동시에 명령어와 데이터를 가져올 수 있어 좀 더 빠르지만 두 번째 메모리를 처리하기 위한 버스가 더 필요하다.

### 프로세서 코어

두 구조는 모두 ALU, 레지스터, 실행 장치의 조합인 CPU가 하나 뿐이다. 1980년대에 처음 만들어진 멀티프로세서 시스템은 단일 CPU 보다 훨씬 더좋은 성능을 얻어내기 위한 방법이다. 여러 CPU를 활용할 수 있도록 프로그램을 병렬화하는 문제는 일반적인 경우에는 풀 수 없는 문제다.

반도체 회로 크기가 줄어들면서 비용도 낮아졌다. CPU를 더 빠르게 만듦으로써 더 나은 성능을 달성할 수 있었다. 하지만 기계가 더 빨리자면 전력을 더 많이 소모하고, 회로 크기는 줄어드는데 기계가 빨려져서 전력을 더 많이 소모하게 되면서 단위 면적당 열 발생은 더 많아졌다. 2000년경 프로세서는 전력 방벽에 부딪힌다. 전력 장벽은 열로 인해 회로를 이루는 물질의 녹는점 이상으로 온도가 올라가는 것을 방지하면서 회로를 소형화 고성능화하기 어려워졌다는 뜻이다.

작아진 회로 크기를 활용한 새로운 해결책을 찾아냈다. CPU의 정의가 바뀌었다. 요즘은 프로세서 코어라고 부른다. 이런 코어가 여러 개 들어가는 멀티코어 프로세서가 일반적으로 쓰인다. 

### 마이크로프로세서와 마이크로컴퓨터

물리적인 패키징에 따라 구조를 구분할 수도 있다. 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어 있지 않으면 마이크로프로세서라고 부른다. 반면 모든 요소를 한 칩 안에 패키징하면 마이크로컴퓨터라고 부른다.

칩 안에서 메모리가 차지하는 영역이 크기 때문에 일반적으로 마이크로프로세서보다 마이크로컴퓨터가 덜 강력하다. 

마이크로프로세서는 보통 큰 시스템에 들어가는 부품으로 쓰이고, 마이크로컴퓨터는 식기세척기 등에서 찾을 수 있는 작은 컴퓨터다.

단일 칩 시스템(SoC, System on a Chip)은 더 복잡한 마이크로컴퓨터를 뜻한다. 핸드폰 등의 장치에서 볼 수 있다.

## 프로시저, 서브루틴, 함수

함수는 코드를 재사용하는 주요 수단이다.

함수는 어떻게 작동할까? 함수를 호출하는 부분에서 함수를 실행하고 다시 원래 자리로 돌아올 방법이 필요하다. 원래 자리로 돌아오기 위해서는 어디서 함수로 들어갔는지를 기억해야 한다. 이 위치는 바로 프로그램 카운터의 값이다. 명령어 집합을 활용해 함수를 호출한다.

함수를 실행한 다음에 돌아와야 하는 주소를 계산해야 한다. 반환 주소를 계산하기 위해 명령어를 몇개 사용해야 하고, 세제곱을 계산할 숫자를 누산기에 넣는 코드와 함수를 호출하는 코드가 차지하는 주소도 감안해야 한다. 반환 주소는 프로그램 시작(100번지)으로부터 5개의 명령어가 지난 다음이다. 이 값을 200번지에 넣는다. 함수를 호출하면 함수가 실행되고, 함수 안에 있는 모든 코드를 실행하고 나면 200번지에 있는 값을 사용해 간접 분기를 한다. 간접 분기를 한 결과는 105번지다.

이 과정은 상당히 많은 작업이 필요하기 때문에 대부분의 기계는 이런 과정을 돕는 명령어를 제공한다. ARM 프로세서에는 링크 레지스터를 사용해 분기 명령어가 있다.

## 스택

함수는 단순한 코드로만 이뤄지지 않는다. 함수가 다른 함수를 호출하거나 함수가 자기 자신을 호출하는 경우(재귀)도 있다. 

재귀 함수를 구현하면 문제가 생긴다. 반환값을 저장할 위치가 한군데뿐이기 때문에 재귀적인 함수는 이미 들어 있떤 반환값을 덮어써서 되돌아갈 위치를 잃어버리기 때문에 자기 자신을 호출할 수가 없다.

재귀 함수가 제대로 작동하려면 반환 주소를 여럿 저장할 수 있어야 한다. 함수에서 호출 지점으로 반환할 때 저장된 주소 중 어떤 주소를 사용할지 결정할 수 있어야 한다. 깊이 우선 순회, 너비 우선 순회 방식이 있으며, 트리에서 한 수준을 내려갈 때마다 돌아올 위치를 기억해야 한다. 원래 위치로 돌아오고 나면 저장했던 위치는 더 이상 필요하지 않다.

이 때 필요한 것이 스택 구조이다. 함수를 호출할 때는 반환 주소를 맨 위에 넣는다. 함수 호출에서 돌아올 때는 맨 위를 보고 반환 주소를 결정한 다음, 제거한다. 더 이상 들어갈 공간이 없으면 스택 오버플로, 빈 스택에서 가져오려고 하는 경우를 스택 언더플로라고 부른다.

모든 함수는 자신이 200번지를 통해 전달받은 반환 주소를 나중에 사용하기 위해 스택에 넣을 수 있다. 스택이 아주 중요하기 때문에 대부분의 컴퓨터 하드웨어는 스택을 지원한다. 소프트웨어로 스택 오버플로를 항상 검사하지 않아도 되도록 돕는 한계 레지스터를 지원을 포함한다.

스택은 단지 반환 주소를 저장하기 위한 장소는 아니다. 함수를 호출할 때 지역 변숫값을 그냥 덮어쓰면 안되기 때문에 지역 변수도 스택에 저장해야 한다. 각각의 함수 호출이 서로 독립적일 수 있게 한다. 함수가 호출될 때마다 스택에 저장되는 데이터의 모음을 스택 프레임이라고 부른다.

## 인터럽트

폴링(polling)이란 하나의 장치(또는 프로그램)가 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치(또는 프로그램)의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식을 말한다.

프로그램의 구조를 잘 재배치해서 이런 작업을 더 잘 처리하는 것은 불가능하다. 실행 중인 프로그램을 잠깐 중단시켜서 주의를 기울여야 하는 외부의 요소에 대응할 수 있게 만들 방법이 필요하다. 실행 장치에 새로운 하드웨어 기능을 추가해야 한다.

요즘 프로세서 대부분에는 인터럽트 시스템이 들어간다. 인터럽트 시스템은 적절한 신호가 들어오면 CPU 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함한다. 핀은 칩에 연결된 전기적 접점을 뜻하는 말이다. 많은 프로세서 칩에는 톱합 주변장치가 들어있고 내부적으로 인터럽트 시스템에 연결되어 있다.

인터럽트 시스템이 작동되는 방식. CPU가 주의를 기울여야 하는 주변장치는 인터럽트 요청을 생성한다. 프로세서는 현재 실행 중인 명령어를 끝까지 실행한다. 그 후 프로세서는 현재 실행 중인 프로그램을 잠시 중단시키고 인터럽트 핸들러라는 전혀 다른 프로그램을 실행한다. 인터럽트 핸들러가 필요한 작업을 다 마치고 나면 원래 실행 중이던 프로그램이 중단된 위치부터 다시 실행을 계속한다. 인터럽트 핸들러는 함수다.

고려해야 할 요소가 있다. 

1. 인터럽트에 대한 응답 시간이다. 인터럽트 처리를 정해 시간 안에 끝내야 한다.
2. 인터럽트를 서비스하고 나중에 다시 원래대로 돌아오기 위해서는 현재 상태를 저장할 방법이 필요하다. 인터럽트 핸들러는 레지스터를 저장했다가 나중에 다시 원래 프로그램으로 돌아오기 전에 레지스터값을 복구해야 한다.

인터럽트 시스템은 서비스 후 돌아올 프로그램 위치를 스택에 저장한다. 자신이 덮어쓸 레지스터를 모두 저장해야 할 책임이 있다. 저장해야 하는 요소를 최적화해 가장 빨리 서비스할 수 있다.

컴퓨터가 어떻게 인터럽트 핸들러 위치를 찾을 수 있을까? 보통은 인터럽트 핸들러 주소를 저장하기로 약속한 메모리 주소가 존재한다. 이 주소에는 여러 인터럽트 벡터가 들어 있고, 각 인터럽트 벡터는 CPU가 지원하는 각 인터럽트에 대한 핸들러 주소를 지정한다.  인터럽트 벡터는 단지 메모리 위치를 가리키는 포인터일 뿐이다. 인터럽트가 일어나면 컴퓨터는 인터럽트 벡터에 저장된 주소를 살펴보고 제어를 그 주소로 옮긴다.

많은 기계가 물리적인 주소를 벗어나는 주소를 사용하려고 시도하거나, 스택 오버플로가 일어나는 등의 예외 상황에 대한 인터럽트 벡터를 제공한다. 예외를 인터럽트 핸들러를 통해 처리하면 인터럽트 핸들러 안에서 문제를 해결함으로써 오류가 생긴 프로그램이 계속 실행될 수 있는 경우도 있다.

여러 가지 종류의 인터럽트 제어가 가능하다. 입터럽트를 중단시킬 수 있는 마스크가 있는 경우가 자주 있다. 종종 인터럽트 간의 우선순위가 있어 더 중요한 인터럽트를 먼저 처리해준다. 일정 시간이 지나면 인터럽트를 발생시킬 수 있는 내장 타이머도 하나 이상 들어 있다.

다른 일반 프로그램들은 접근할 수 없는 물리적 인터럽트에 접근할 수 있는 경우가 있다. 일종의 가상 인터럽트나 소프트웨어 인터럽트 시스템을 제공한다. 

## 상대 주소 지정

여러 프로그램을 동시에 실행하려면 각 프로그램을 서로 전환시켜 줄 수 있는 일종의 관리자 프로그램이 필요하다. 이 프로그램을 운영체제 또는 운영체제 커널이라고 부른다. OS를 시스템 프로그램이라 부르고 다른 모든 프로그램을 사용자 프로그램이나 프로세스라고 부른다.

간단한 운영체제는 [사용자 프로그램을 메모리로 읽기] ⇒ [상태 복원] ⇒ [사용자 프로그램 실행] ⇒ [타이머 인터럽트] ⇒ [사용자 프로그램 중단] ⇒ [상태 저장] ⇒ [사용자 프로그램 메모리로 읽기] 순서로 작동한다.

여기서 OS는 타이머를 사용해 사용자 프로그램을 전환시켜줄 때가 됐는지 판단한다. 이런 스케줄링 기법을 시분할이라고 한다. 사용자 프로그램 상태 또는 문맥은 레지스터의 상태와 프로그램이 사용 중인 메모리의 상태를 뜻한다. 이때 메모리에는 스택도 포함된다.

이 방법은 잘 작동하지만 아주 느리다. 프로그램을 메모리로 불러오되 각 프로그램에게 각기 다른 공간을 허용할 수 있으면 훨씬 더 빠르게 시분할 실행이 가능하다.

이 문제를 해결하는 방법은 상대 주소 지정을 사용하는 것이다. 상대 주소 지정은 명령어에 들어 있는 주소를 0부터 시작하는 위치로 해석하지 않고, 명령어의 주소를 기준으로 하는 상대적인 주소로 해석한다. 명령어가 들어있는 주소가 1이고 100이라는 주소는 99가 된다. 상대 주소 지정을 사용하면 프로그램을 메모리의 원하는 위치로 자유롭게 재배치 할 수 있다.

## 메모리 관리 장치

대부분의 마이크로프로세서에는 메모리 관리 장치(MMU)가 있다. MMU가 들어 있는 시스템은 가상 주소와 물리 주소를 구분한다. 프로그램은 가상 주소를 사용해 작성되고, MMU는 가상 주소를 물리 주소로 변환해준다.

MMU와 인덱스 레지스터의 차이. MMU의 가상 주소 범위는 물리적 메모리 주소보다 큰 경우가 많다. MMU는 가상 메모리 주소를 두 부분으로 나눈다. 주소의 하위(LSB 쪽) 부분은 물리적 주소 범위와 같다. 상위(MSB 쪽) 부분은 페이지 테이블이라는 RAM 영역을 통해 주소를 변환한다. 

현대적 프로세서의 MMU는 페이지 테이블 크기가 정해져 있다. 전체 페이지 테이블 항목은 주 메모리에 저장되거나 주 메모리가 부족한 경우 디스크에 저장된다. MMU는 페이지 테이블 항목 중 일부를 필요할 때만 자신의 페이지 테이블로 읽어 들인다.

일부 MMU 설계는 페이지 테이블에 제어 비트를 추가 제공한다. 이런 제어 비트의 예로 실행 불가 비트를 들 수 있다. 어떤 페이지에 대해 실행 불가 비트가 설정되어 있으면 CPU가 이 페이지에 있는 명령어를 실행할 수 없다. 따라서 프로그램이 실수로 자기 데이터를 실행하는 경우를 방지할 수 있다. 데이터 부분을 실행할 수 있으면 보안 문제가 생길 수도 있다. 또 따른 일반적인 제어 비트는 페이지를 읽기 전용으로 만드는 비트가 있다.

프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 페이지 폴트 예외가 발생한다. 이런 동작은 스택 오버플로 등이 일어날 때 유용하게 쓰일 수 있다. 이 예외가 발생하면 OS는 실행 중인 프로그램을 중단시키는 대신 MMU가 추가 메모리를 할당하게 해서 스택 공간을 늘리고 사용자 프로그램 실행을 계속할 수 있다.

MMU로 인해 폰 노이만 구조와 하버드 구조의 구분이 의미 없어졌다. 단일 메모리 버스만 사용하는 폰 노이만 구조의 시스템도 명령어 메모리와 데이터 메모리를 분리해 제공할 수 있다.

## 가상 메모리

운영체제는 희소한 하드웨어 자원을 사용하려고 경합하는 프로그램들 사이의 자원 분배를 관리한다. OS는 MMU를 사용해 사용자 프로그램에게 가상 메모리를 제공한다.

요청받은 메모리가 사용 가능한 메모리의 크기보다 크면 어떻게 될까? OS는 현재 필요하지 않은 메모리 페이지를 더 느리지만 더 용량이 큰 대용량 저장장치인 디스크로 옮긴다.(스왑 아웃). 스왑 아웃한 페이지에 프로그램이 접근하면 운영체제는 필요한 메모리 공간을 확보하고 요청받은 페이지를 다시 메모리로 불러들인다(스왑 인). 이런 식으로 페이지를 처리하는 것을 요구불 페이징이라고 부른다.

스와핑이 일어나면 시스템 성능이 크게 저하된다. 프로그램을 실행 못하는 것보다는 느리더라도 스와핑을 통해 프로그램을 실행하는 편이 더 낫다. 가상 메모리 시스템은 성능 저하를 막기 위해 다양한 기법을 활용하는데, 그 중 하나는 페이지 접근을 추적해 스왑 아웃할 페이지를 결정하는 최소 최근 사용 알고리즘이다. 이 알고리즘은 최근에 가장 자주 사용된 페이지는 물리 메모리에 그대로 남겨두고 최근에 가장 덜 사용한 페이지를 스왑한다.

## 시스템 공간과 사용자 공간

멀티태스킹 시스템은 모든 프로그램에게 자신이 컴퓨터 안에서 실행되는 유일한 프로그램이라는 환상을 심어준다. MMU는 각 프로세스에게 자신만의 메모리 주소 공간을 제공해서 이런 환상을 키워준다. 하지만 I/O 장치가 끼어들면 이런 환상을 유지하기 힘들다. 예를 들어, 운영체제가 타이머 장치를 사용해서 실행 중인 프로그램을 다른 프로그램으로 전환할 시점을 알아낸다. 운영체제는 초당 발생할 인터럽트 횟수에 맞춰 타이머를 설정한다. 사용자 프로그램이 이 타이머 설정을 한 시간에 한 번만 인터럽트하도록 변경하면 모든 것이 예상과 다르게 작동한다. 마찬가지로 사용자 프로그램이 MMU의 설정을 마음대로 바꿀 수 있다면 MMU가 프로그램을 서로 격리시키지 못할 것이다.

여러 CPU는 이런 문제를 해결할 수 있는 추가 하드웨어를 제공한다. CPU에는 컴퓨터가 시스템 모드에 있는지 사용자 모드에 있는지 결정하는 비트가 어떤 레지스터 안에 들어 있다. I/O를 처리하는 명령어 등 일부 명령어는 특권 명령어라서 오직 시스템 모드에서만 실행할 수 있다. 트랩이나 시스템 콜이라고 부르는 특별한 명령어를 통해 사용자 모드에서 실행 중인 프로그램이 시스템 모드 프로그램에게 요청을 보낼 수 있다.

장점

1. 사용자 프로그램으로부터 운영체제를 보호하고, 사용자 프로그램을 다른 사용자 프로그램으로부터 보호한다.
2. 사용자 프로그램이 MMU 등의 몇몇 요소에 손을 댈 수 없기 때문에 운영체제가 프로그램에 대한 자원 할당을 전적으로 제어할 수 있다.

## 메모리 계층과 성능

과거에는 CPU와 메모리가 같은 속도로 작업했다. 하지만 CPU가 더더욱 빨라져 메모리는 CPU보다 속도가 뒤쳐졌다. CPU가 느린 메모리를 기다리느라 아무 일도 하지 않은 경우를 줄이기 위한 방법을 쓰기 시작했다.

가상 메모리와 스와핑은 메모리 계층이라는 개념을 소개했다. 사용자 프로그램에게는 모든 메모리가 같아 보이지만 메모리 시스템 내부에서 일어나는 일은 시스템 성능에 큰 영향을 끼친다.

컴퓨터는 1초에 수십억 개의 명령어를 실행할 수 있다. 하지만 CPU가 기다려야 한다면 많은 일을 해낼 수 없다.

프로세서에 레지스터라는 빠르고 비싼 메모리가 수백 개가 들어 있다. 레지스터가 전체 메모리에서 차지하는 비율은 점점 작아져 왔다. 프로세서는 보통 RAM으로 이뤄진 주 메모리와 통신하는데, 주 메모리는 프로세서보다 1/10 정도밖에 속도가 나지 않는다. 디스크 드라이브 등의 대량 저장장치는 프로세서보다 백만 배 느릴 수도 있다.

CPU가 메모리를 기다리느라 많은 시간을 소비해야 하는데, 이를 해결하기 위해 캐시라는 하드웨어를 CPU에 추가한다. 

CPU 메모리 컨트롤러 하드웨어는 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져온다. 메모리에 접근하는 패턴이 순차적이 아니어서 캐시 실패가 일어나도 CPU는 고속 메모리 접근 모드가 가능하기 때문에 좀 더 유리하다. 캐시 실패는 CPU가 캐시에서 어떤 내용을 찾았는데 캐시에 그 데이터가 없어서 메모리를 읽어야 하는 경우를 뜻한다. 캐시 적중은 CPU가 원하는 내용을 찾은 경우를 뜻한다.

캐시 메모리에도 계층이 있다. 모든 캐시가 같은 칩 안에 존재하는 경우에도 CPU에서 멀어질수록 캐시는 더 느려지고 더 커진다. 이들을 L1, L2, L3 캐시라고 부른다. 디스패처가 들어 있는데, 여러 가지 크기의 장바구니, 박스, 트럭에 내용물을 채워 넣거나 내용물을 꺼내는 일을 담당하는 큰 논리 회로다.
