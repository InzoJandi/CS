컴퓨터 아키텍처라는 말은 컴퓨터의 여러 구성요소를 배치하는 방법을 뜻한다.

메모리와 관련한 구조 개선을 다룬다. 명령어 집합 설계, 다른 유형의 레지스터들, 전력 관리, 멋진 실행 장치 같은 구조도 살펴본다. 멀티태스킹은 여러 프로그램이 동시에 실행되는 것처럼 보이게 하는 기능을 뜻하는데, 이 말은 프로그램들의 실행을 제어하기 위한 감독 프로그램인 운영체제가 있어야 한다는 사실을 암시한다.

## 기본적인 구조 요소들

흔한 두 가지 컴퓨터 구조는 폰 노이만 구조와 하버드 구조다. 두 구조의 차이는 메모리 배열뿐이다. 나머지가 모두 같다면 메모리에서 동시에 명령어와 데이터를 가져올 수 없기 때문에 폰 노이만 구조가 약간 더 느리다. 하버드 구조는 동시에 명령어와 데이터를 가져올 수 있어 좀 더 빠르지만 두 번째 메모리를 처리하기 위한 버스가 더 필요하다.

### 프로세서 코어

두 구조는 모두 ALU, 레지스터, 실행 장치의 조합인 CPU가 하나 뿐이다. 1980년대에 처음 만들어진 멀티프로세서 시스템은 단일 CPU 보다 훨씬 더좋은 성능을 얻어내기 위한 방법이다. 여러 CPU를 활용할 수 있도록 프로그램을 병렬화하는 문제는 일반적인 경우에는 풀 수 없는 문제다.

반도체 회로 크기가 줄어들면서 비용도 낮아졌다. CPU를 더 빠르게 만듦으로써 더 나은 성능을 달성할 수 있었다. 하지만 기계가 더 빨리자면 전력을 더 많이 소모하고, 회로 크기는 줄어드는데 기계가 빨려져서 전력을 더 많이 소모하게 되면서 단위 면적당 열 발생은 더 많아졌다. 2000년경 프로세서는 전력 방벽에 부딪힌다. 전력 장벽은 열로 인해 회로를 이루는 물질의 녹는점 이상으로 온도가 올라가는 것을 방지하면서 회로를 소형화 고성능화하기 어려워졌다는 뜻이다.

작아진 회로 크기를 활용한 새로운 해결책을 찾아냈다. CPU의 정의가 바뀌었다. 요즘은 프로세서 코어라고 부른다. 이런 코어가 여러 개 들어가는 멀티코어 프로세서가 일반적으로 쓰인다. 

### 마이크로프로세서와 마이크로컴퓨터

물리적인 패키징에 따라 구조를 구분할 수도 있다. 메모리와 I/O가 프로세서 코어와 같은 패키지에 들어 있지 않으면 마이크로프로세서라고 부른다. 반면 모든 요소를 한 칩 안에 패키징하면 마이크로컴퓨터라고 부른다.

칩 안에서 메모리가 차지하는 영역이 크기 때문에 일반적으로 마이크로프로세서보다 마이크로컴퓨터가 덜 강력하다. 

마이크로프로세서는 보통 큰 시스템에 들어가는 부품으로 쓰이고, 마이크로컴퓨터는 식기세척기 등에서 찾을 수 있는 작은 컴퓨터다.

단일 칩 시스템(SoC, System on a Chip)은 더 복잡한 마이크로컴퓨터를 뜻한다. 핸드폰 등의 장치에서 볼 수 있다.

## 프로시저, 서브루틴, 함수

함수는 코드를 재사용하는 주요 수단이다.

함수는 어떻게 작동할까? 함수를 호출하는 부분에서 함수를 실행하고 다시 원래 자리로 돌아올 방법이 필요하다. 원래 자리로 돌아오기 위해서는 어디서 함수로 들어갔는지를 기억해야 한다. 이 위치는 바로 프로그램 카운터의 값이다. 명령어 집합을 활용해 함수를 호출한다.

함수를 실행한 다음에 돌아와야 하는 주소를 계산해야 한다. 반환 주소를 계산하기 위해 명령어를 몇개 사용해야 하고, 세제곱을 계산할 숫자를 누산기에 넣는 코드와 함수를 호출하는 코드가 차지하는 주소도 감안해야 한다. 반환 주소는 프로그램 시작(100번지)으로부터 5개의 명령어가 지난 다음이다. 이 값을 200번지에 넣는다. 함수를 호출하면 함수가 실행되고, 함수 안에 있는 모든 코드를 실행하고 나면 200번지에 있는 값을 사용해 간접 분기를 한다. 간접 분기를 한 결과는 105번지다.

이 과정은 상당히 많은 작업이 필요하기 때문에 대부분의 기계는 이런 과정을 돕는 명령어를 제공한다. ARM 프로세서에는 링크 레지스터를 사용해 분기 명령어가 있다.

## 스택

함수는 단순한 코드로만 이뤄지지 않는다. 함수가 다른 함수를 호출하거나 함수가 자기 자신을 호출하는 경우(재귀)도 있다. 

재귀 함수를 구현하면 문제가 생긴다. 반환값을 저장할 위치가 한군데뿐이기 때문에 재귀적인 함수는 이미 들어 있떤 반환값을 덮어써서 되돌아갈 위치를 잃어버리기 때문에 자기 자신을 호출할 수가 없다.

재귀 함수가 제대로 작동하려면 반환 주소를 여럿 저장할 수 있어야 한다. 함수에서 호출 지점으로 반환할 때 저장된 주소 중 어떤 주소를 사용할지 결정할 수 있어야 한다. 깊이 우선 순회, 너비 우선 순회 방식이 있으며, 트리에서 한 수준을 내려갈 때마다 돌아올 위치를 기억해야 한다. 원래 위치로 돌아오고 나면 저장했던 위치는 더 이상 필요하지 않다.

이 때 필요한 것이 스택 구조이다. 함수를 호출할 때는 반환 주소를 맨 위에 넣는다. 함수 호출에서 돌아올 때는 맨 위를 보고 반환 주소를 결정한 다음, 제거한다. 더 이상 들어갈 공간이 없으면 스택 오버플로, 빈 스택에서 가져오려고 하는 경우를 스택 언더플로라고 부른다.

모든 함수는 자신이 200번지를 통해 전달받은 반환 주소를 나중에 사용하기 위해 스택에 넣을 수 있다. 스택이 아주 중요하기 때문에 대부분의 컴퓨터 하드웨어는 스택을 지원한다. 소프트웨어로 스택 오버플로를 항상 검사하지 않아도 되도록 돕는 한계 레지스터를 지원을 포함한다.

스택은 단지 반환 주소를 저장하기 위한 장소는 아니다. 함수를 호출할 때 지역 변숫값을 그냥 덮어쓰면 안되기 때문에 지역 변수도 스택에 저장해야 한다. 각각의 함수 호출이 서로 독립적일 수 있게 한다. 함수가 호출될 때마다 스택에 저장되는 데이터의 모음을 스택 프레임이라고 부른다.

## 인터럽트

폴링(polling)이란 하나의 장치(또는 프로그램)가 충돌 회피 또는 동기화 처리 등을 목적으로 다른 장치(또는 프로그램)의 상태를 주기적으로 검사하여 일정한 조건을 만족할 때 송수신 등의 자료처리를 하는 방식을 말한다.

프로그램의 구조를 잘 재배치해서 이런 작업을 더 잘 처리하는 것은 불가능하다. 실행 중인 프로그램을 잠깐 중단시켜서 주의를 기울여야 하는 외부의 요소에 대응할 수 있게 만들 방법이 필요하다. 실행 장치에 새로운 하드웨어 기능을 추가해야 한다.

요즘 프로세서 대부분에는 인터럽트 시스템이 들어간다. 인터럽트 시스템은 적절한 신호가 들어오면 CPU 실행을 잠깐 중단시킬 수 있는 핀이나 전기 연결을 포함한다. 핀은 칩에 연결된 전기적 접점을 뜻하는 말이다. 많은 프로세서 칩에는 톱합 주변장치가 들어있고 내부적으로 인터럽트 시스템에 연결되어 있다.

인터럽트 시스템이 작동되는 방식. CPU가 주의를 기울여야 하는 주변장치는 인터럽트 요청을 생성한다. 프로세서는 현재 실행 중인 명령어를 끝까지 실행한다. 그 후 프로세서는 현재 실행 중인 프로그램을 잠시 중단시키고 인터럽트 핸들러라는 전혀 다른 프로그램을 실행한다. 인터럽트 핸들러가 필요한 작업을 다 마치고 나면 원래 실행 중이던 프로그램이 중단된 위치부터 다시 실행을 계속한다. 인터럽트 핸들러는 함수다.

고려해야 할 요소가 있다. 

1. 인터럽트에 대한 응답 시간이다. 인터럽트 처리를 정해 시간 안에 끝내야 한다.
2. 인터럽트를 서비스하고 나중에 다시 원래대로 돌아오기 위해서는 현재 상태를 저장할 방법이 필요하다. 인터럽트 핸들러는 레지스터를 저장했다가 나중에 다시 원래 프로그램으로 돌아오기 전에 레지스터값을 복구해야 한다.

인터럽트 시스템은 서비스 후 돌아올 프로그램 위치를 스택에 저장한다. 자신이 덮어쓸 레지스터를 모두 저장해야 할 책임이 있다. 저장해야 하는 요소를 최적화해 가장 빨리 서비스할 수 있다.

컴퓨터가 어떻게 인터럽트 핸들러 위치를 찾을 수 있을까? 보통은 인터럽트 핸들러 주소를 저장하기로 약속한 메모리 주소가 존재한다. 이 주소에는 여러 인터럽트 벡터가 들어 있고, 각 인터럽트 벡터는 CPU가 지원하는 각 인터럽트에 대한 핸들러 주소를 지정한다.  인터럽트 벡터는 단지 메모리 위치를 가리키는 포인터일 뿐이다. 인터럽트가 일어나면 컴퓨터는 인터럽트 벡터에 저장된 주소를 살펴보고 제어를 그 주소로 옮긴다.

많은 기계가 물리적인 주소를 벗어나는 주소를 사용하려고 시도하거나, 스택 오버플로가 일어나는 등의 예외 상황에 대한 인터럽트 벡터를 제공한다. 예외를 인터럽트 핸들러를 통해 처리하면 인터럽트 핸들러 안에서 문제를 해결함으로써 오류가 생긴 프로그램이 계속 실행될 수 있는 경우도 있다.

여러 가지 종류의 인터럽트 제어가 가능하다. 입터럽트를 중단시킬 수 있는 마스크가 있는 경우가 자주 있다. 종종 인터럽트 간의 우선순위가 있어 더 중요한 인터럽트를 먼저 처리해준다. 일정 시간이 지나면 인터럽트를 발생시킬 수 있는 내장 타이머도 하나 이상 들어 있다.

다른 일반 프로그램들은 접근할 수 없는 물리적 인터럽트에 접근할 수 있는 경우가 있다. 일종의 가상 인터럽트나 소프트웨어 인터럽트 시스템을 제공한다.
