## 비트(bit)

비트(bit)라는 단어는 2진법을 사용한다는 뜻의 ‘binary’와 숫자를 뜻하는 ‘digit’가 기묘하게 합쳐진 말이다. 비트는 2진법을 사용한다. 이는 비트 상자에는 모스 부호의 점과 선처럼 두 가지 기호 중 하나만 담을 수 있다는 뜻이다.

# 논리 연산

다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 이런 동작을 논리 연산이라고 한다.

## 드모르간의 법칙

 a AND b라는 연산은 NOT(NOT a OR NOT b)와 같다고 말한다. 긍정적인 논리에 더해 부정적인 논리를 기술하는 명제를 사용할 때 드모르간의 법칙을 활용할 수 있다. 이런 논리를 제대로 활용하면 비용을 최소화할 수 있다.

# 정수를 비트로 표현하는 방법

## 양의 정수 표현

2진수 체계는 10을 밑으로 하지 않고 2를 밑으로 하는 수 체계다. 10진수로는 5,028이 네 자리 숫자라고 말할 수 있다. 2진수로는 5,028이 13비트 수가 된다.

2진수에서 가장 오른쪽의 비트를 가장 작은 유효 비트(least significant bit)라고 부르고, 가장 왼쪽의 비트를 가장 큰 유효 비트(most significant bit)라고 부른다. 이는 LSB, MSB라고 부르기도 한다.

## 이진수 덧셈

덧셈의 결과가 우리가 사용할 비트의 개수로 표현할 수 있는 범위를 벗어나면 오버플로가 발생한다. 오버플로란 말은 MSB에서 올림이 발생했다는 뜻이다. 컴퓨터에는 조건 코드 레지스터(condition code register)라는 것이 있어 몇 가지 이상한 정보를 담아두는데 이런 정보 중에는 오버플로 비트가 있다. 이 비트에는 MSB에서 발생한 올림값이 들어간다. 이 비트값을 보면 오버플로가 발생했는지 알 수 있다.

## 음수 표현

4비트로 수를 16가지만 표현할 수 있다는 말이 꼭 4비트로는 0부터 15까지만 표현할 수 있다는 뜻은 아니다. 언어는 문맥과 의미를 통해 작용한다. 이 말은 비트를 해석하는 새로운 문맥을 만들 수 있다는 뜻이다.

### 부호와 크기

음수와 양수를 구별하기 위해 흔히 부호를 사용한다. 우리는 가장 왼쪽 비트(MSB)를 부호에 사용하기로 멋대로 결정했다. 따라서 4비트 중에 3비트가 남고, 이를 사용하면 0부터 7까지의 수를 표현할 수 있다. 부호 비트가 0이면 이 2진수를 양수로 취급하고 부호 비트가 1이면 이 2진수를 음수로 취급한다. 한 비트를 부호에 사용하고 나머지 비트를 수의 크기, 즉 0부터의 거리를 표현하기 위해 사용하는 이런 방법을 부호와 크기 표현법이라고 말한다.

부호와 크기 표현법은 두 가지 이유로 널리 쓰이지 못하고 있다.

1. 비트들을 구성하려면 비용이 드는데 0을 표현하는 방법이 두 가지라서 비용이 낭비된다.
2. XOR과 AND를 통한 덧셈 계산을 사용할 수 없다.

### 1의 보수

음수를 표현하는 또 다른 방법으로는 양수의 모든 비트를 뒤집는 방법이 있다. 이런 방법을 1의 보수 표현법이라고 부른다. 1의 보수 표현법에서도 부호와 크기 표현법과 비슷하게 비트들을 부호 비트와 나머지로 나눈다. 1의 보수라는 문맥에서는 NOT 연산자를 통해 보수를 얻는다. 0111(+7)의 각 비트를 뒤집으면 1000(-7)을 얻을 수 있음을 알 수 있다. 1의 보수 표현에서도 0을 두 가지 방식으로 표현한다는 문제가 여전히 존재한다. 1의 보수에서도 덧셈을 쉽게할 수 없는데, MSB 쪽에서 올림이 발생한 경우에는 LSB로 올림을 전달해야 한다. 이를 순환 올림이라고 한다.

### 2의 보수

4비트 수의 경우 +1은 0001이다. 1111을 0001에 더하면 0000이 된다. 따라서 앞으로는 1111을 -1을 표현하는 패턴으로 사용한다. 이런 표현법을 2의 보수 표현법이라고 하며, 이 방법은 부호가 있는 정수를 표현할 때 가장 널리 쓰이는 방법이다. 어떤 수의 비트를 뒤집고 1을 추가하면 음수를 얻을 수 있다. 이때 MSB에서 올림이 발생하면 이 값은 버린다.

2의 보수에는 0의 중복 표현이 문제가 없는지 확인해보자. 0000의 모든 비트를 뒤집으면 1111을 얻는다. 1111에 1을 더하면 [1]0000이 되는데 이 숫자는 5비트이므로 우리가 사용할 수 있는 4비트보다 크다. 따라서 1을 올림 비트로 생각하고 무시한다. 결과는 0000인데 이 값은 처음에 시작한 0과 같다. 따라서 2의 보수 표현법에서는 0을 표현하는 방법이 하나뿐이다.

# 실수를 표현하는 방법

실수를 표기하기 위해 2진 소수점을 표현할 방법이 필요하다.

## 고정소수점 표현법

4비트가 있다면 그중 2비트는 2진 소수점의 오른쪽에 있는 분수들을 표현하는 데 쓰고, 2비트는 왼쪽에 있는 숫자들을 표현하는 데 쓸 수 있다. 소수점의 위치가 항상 일정하기 때문에 고정소수점 표현법이라고 부른다.

디지털 신호 처리 장치 등 특별한 목적에 쓰이는 일부 컴퓨터에서 사용된다.

## 부동소수점 표현법

플랑크 상수부터 아보가드로 수에 이르는 범위의 값을 2진수로 표현한다는 문제를 해결하기 위해, 과학적 표기법을 2진수에 적용한다. 가수 부분은 (소수점 왼쪽이 한 자리뿐인) 2진 소수, 지수 부분은 2의 거듭제곱 횟수를 표현한다.

부동소수점 표현법이라고 부르는 이유가 헷갈린다. 소수점의 위치가 같아 보이지만 소수점 위치는 정해져 있지 않다.

지수의 밑인 2라는 숫자를 비트로 표현할 필요 없다. 부동소수점 수의 정의상 밑 2는 항상 정해져 있다. 부동소수점 표현법은 지수와 가수를 분리함으로써 수를 표현할 때 필요한 0을 모두 저장하지 않고도 큰 수나 작은 수를 표현할 수 있다.

부동소수점 표현법은 비효율적이다.

1. 비트 조합 중에 낭비되는 부분이 있다.
2. 비트 패턴이 가능한 모든 수를 표현하지 못한다.

## IEEE 부동소수점 수 표준

부동소수점 수 시스템은 실수를 표현하는 표준 방법이다. 가수와 지수에 대해 각각 부호 비트를 사용한다. 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있다. 낭비되는 비트 조합을 최소화하고 반올림을 쉽게 하기 위한 여러 가지 트릭이 사용된다. IEEE 754라는 표준은 이 모든 기능을 정의한다.

1. 똑같은 비트를 사용하더라도 정밀도를 높이기 위해 정규화한다. 정규화는 가수를 조정해서 맨 앞에 0이 없게 만드는 것이다. 가수를 조정하려면 지수도 조정해야 한다. 
2. 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략하는 것이다. 가수에 1비트를 더 사용할 수 있다.

두 가지 부동소수점 수가 자주 쓰인다.

1. 기본 정밀도 부동소수점 수(단정도 실수)): 32비트를 사용해 7비트 정밀도로 대략 플러스 마이너스 10의 플러스 마이너스 38승 정도의 범위를 표현할 수 있다.
2. 2배 정밀도 부동소수점 수(배정도 실수): 64비트를 사용해 대략 플러스 마이너스 10의 플러스 마이너스 308승 정도의 범위의 수를 15비트 정밀도로 표현할 수 있다.

두 형태 모두 가수에 대한 부호를 사용한다. 2배 정밀도 수가 기본 정밀도 수보다 지수가 3비트 더 크다는 점을 볼 수 있다. 즉, 지수의 범위는 8배 더 크다. 2배 정밀도 수는 기본 정밀도 수보다 가수가 29비트 더 크다. 비트를 2배나 더 많이 사용한다.

지수에 대해 부호 비트가 따로 존재하지 않는다. 지수 비트가 모두 0이거나 1인 경우에 특별한 의미를 갖게 하고, 실제 지숫값은 나머지 비트 패턴에 넣길 원했다. 편향된 지숫값을 사용해 이를 달성했다. 기본 정밀도의 경우 편향값은 127, 이 말은 127이 지수 0을 표현한다는 뜻이다. 2진수 1을 표현하는 비트 패턴(00000001)은 지수에서 -126을 표현하며, 2진수 254(11111110)는 +127을 표현한다. 2배 정밀도 수도 편향값으로 127 대신 1023을 사용하는 비슷한 방식을 사용한다.

IEEE 754에서 편리한 점은 0으로 나눴을 때 생길 수 있는 양의 무한대나 음의 무한대를 표현하는 비트 패턴 등 여러 가지 특별한 비트 패턴을 제공한다는 점이다. 이런 비트 패턴 중에는 NaN을 표현하는 특별한 값도 있다. 

## 2진 코드화한 10진수 시스템

BCD는 4비트를 사용해 10진 숫자를 하나 표현한다. 12를 BCD로 표현하면 0001 0010이다. 디스플레이나 가속도 센서 등이 BCD를 사용하는 경우가 있다.

BCD는 2진수를 효율적으로 활용하지 못한다. 더 많은 비트를 사용한다.

## 2진수를 다루는 쉬운 방법

### 8진 표현법

8진 표현법은 2진수 비트들을 3개씩 그룹으로 묶는 아이디어다. 100101110001010100을 456124로 표현할 수 있다.

### 16진 표현법

컴퓨터 내부가 8비트의 배수를 사용해 만들어지기 때문에 8진 표현법에 비해 자주 쓰인다. 8의 배수는 4로는 균일하게 나눠지지만 3으로는 그렇지 않다.

1101 → d 0011 → 3 1111 → f 1100 → c 0001 → 1

비트를 4개씩 그룹으로 나눈다. 

## 프로그래밍 언어의 진법 표기법

수학 책에서는 아래 첨자를 사용해 각 진법을 구분한다. 여러 프로그래밍 언어에서는 다음과 같은 표기법을 따른다.

- 0으로 시작하는 숫자는 8진 숫자다. 017은 8진수이며 값은 10진수로 15다.
- 1부터 9 사이의 숫자로 시작하는 숫자는 10진수다. 123은 10진수다.
- 0x가 앞에 붙은 숫자는 16진수다. 0x12f는 16진수이며 값은 10진수 303이다.

## 비트 그룹의 이름

비트는 너무 작아서 기본 단위로 사용하기에는 유용성이 떨어진다. 시간이 지남에 따라 세계적으로 8비트 덩어리가 기본 단위로 널리 쓰이기 시작했고 이를 바이트라고 부른다.

32비트 워드는 각 컴퓨터가 설계상 자연스럽게 사용할 수 있는 비트 묶음의 크기를 가르킨다. 컴퓨터가 빠르게 처리할 수 있는 가장 큰 덩어리를 뜻한다. C나 C++ 등의 언어에서 int라고 선언한 변수가 이런 자연스러운 크기의 2진수를 표현한다. 

킬로바이트 2의 10승, 메가바이트 2의 20승, 기가바이트 2의 30승, 테라바이트 2의 40승

## 텍스트 표현

수를 사용해 문자나 키보드에 있는 다른 기호 등을 표현하는 방법을 살펴본다.

### 아스키 코드

1963년 승자는 정보 교환을 위한 미국 표준 코드(ASCII)였다. 키보드에 있는 모든 기호에 대해 7비트 수 값을 할당했다. 예를 들어, 65는 대문자 A, 66은 대문자 B를 표현한다.

아스키 코드 표에 글자를 출력하는 데 쓰이지 않고 장치를 제어하기 위해 쓰이는 제어 문자가 있다. 상당수는 통신 제어를 위한 문자다. ACK(수신확인)은 ‘메시지를 받았음’이라는 뜻이고, NAK(반수신확인)는 ‘메시지를 받지 못했음’이라는 뜻이다. 

### 다른 표준의 진화

아스키는 영어를  표현하는 데 필요한 모든 문자를 포함해 상당 기간 표준 역할을 했다. 컴퓨터가 널리 쓰이게 됨에 따라 그 밖의 언어를 지원해야 할 필요성이 점차 늘어났고, 국제 표준화 기구(ISO)는 ISO-646과 ISO-8859를 도입했다. JISX 0201, KS C 5601 등의 표준이 생겼다.

비트 가격이 떨어짐에 따라 유니코드라는 새로운 표준이 생겼고, 문자에 16비트 코드를 부여했다. 이후 유니코드는 21비트까지 확장됐으며, 앞으로 모든 문자를 다 표현할 수 있을 것이다.

## 유니코드 반환 형식 8비트

8비트만 사용하면 모든 문자를 표현할 수 있는데 굳이 16비트를 사용해 낭비해도 될 만큼 비트가 저렴하지 않다는 이유로 한 문자를 8비트로 표현한다. 유니코드는 문자 코드에 따라 각기 다른 인코딩을 사용해 이런 문제를 해결한다. 인코딩은 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴을 뜻한다.

유니코드 변환 형식 8비트(UTF-8)라는 인코딩 방법이 하위 호환성과 효율성 때문에 가장 널리 쓰이고 있다. UTF-8은 모든 아스키 문자를 8비트로 표현하기 때문에 아스키 데이터를 인코딩할 때는 추가 공간이 필요하지 않다. UTF-8은 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않는 방법으로 인코딩한다.

UTF-8은 문자를 8비트 덩어리(옥텟)의 시퀀스로 인코딩한다. UTF-8에서 교묘한 부분은 첫 번째 덩어리(8비트)의 MSB 쪽에 있는 비트들이 8비트 덩어리(옥텟) 시퀀스의 길이를 표현하고, 덩어리의 맨 앞으로 식별하기 쉽다는 데 있다. 프로그램이 문자 경계를 찾아야 하는 경우 이런 특성이 아주 유용하다. 모든 아스키 문자는 7비트에 들어가기 때문에 덩어리를 하나만 사용해 표현할 수 있다. 영어의 경우 비 아스키 기호를 사용하는 언어보다 더 적은 용량으로 문자를 인코딩할 수 있기 때문에 이런 특성이 아주 편리하다. 

## 문자를 사용한 수 표현

UTF-8은 문자를 표현하는 비트들(0000000001000001)로부터 나온 숫자들(0x0041)을 표현하는 숫자들을 표현하는 숫자들(UTF-8로 인코딩한 값)을 표현하기 위해 숫자(실제 UTF-8로 인코딩한 0x41)들을 사용한다. 문자를 사용해 수를 표현할 수도 있다.

### 출력 가능하게 변경한 인코딩

출력 가능하게 변경한 인코딩은 쿼티드 프린터블 인코딩, 혹은 QP 인코딩이라고도 하는데, 8비트 데이터를 7비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법이다.

QP 인코딩은 전자우편 첨부를 처리하기 위해 만들어졌다. = 다음에 바이트와 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트 값을 표현한다. QP에서 =를 표현하려면 =3D를 사용해야 한다. 

### 베이스64 인코딩

QR 인코딩이 잘 작동하기는 하지만 1바이트를 표현하기 위해 3바이트를 사용하기 때문에 비효율적이다. 베이스64 인코딩은 3바이트 데이터를 4문자로 표현하기 때문에 더 효율적이다. 3바이트 데이터의 24비트를 네 가지 6비트 덩어리로 나누고, 각 덩어리의 6비트 값에 출력 가능한 문자를 할당해 표현한다. 모든 3바이트 조합을 4바이트 조합으로 변환할 수 있다. 원본 데이터 길이가 3바이트의 배수라는 보장이 없어 패딩 문자를 도입해 이 문제를 해결한다. 남는 바이트에 =를 붙인다.

### URL 인코딩

URL에는 %26이나 %2F 같은 문자 시퀀스가 존재하는데, 몇몇 문자가 특별한 의미를 지니기 때문이다. 특별한 의미를 지니는 문자를 리터럴로 사용할 필요가 있다.

문자들은 8비트 덩어리의 시퀀스로 표현된다. 각 덩어리는 2개의 16진 문자로 표현할 수 있다. URL 인코딩은 퍼센트 인코딩이라고도 부르는데. % 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 문자를 인코딩한다.

/를 URL에서 사용하되 표현하는 특별한 의미를 뜻하고 싶지는 않은 경우, /를 %2F라는 문자열로 대신한다. 

## 색을 표현하는 방법

컴퓨터 그래픽스는 전자 모눈종이에 해당하는 것에 색을 표현하는 점을 찍어서 그림을 만드는 과정이다. 모눈의 각 격자에 찍는 점을 그림 원소라고 부르고, 줄여서 픽셀이라고 부른다.

빨간색, 녹색, 파란색 광선을 섞어서 색을 만들어내는데, 이 색 표현법을 RGB라고 부른다. 색은 컬러 큐브라는 것으로 표현할 수 있다. 컬러 큐브에서 각 축은 주 색을 표현한다. 값이 0이면 끈다는 뜻이고, 1이면 최대로 켠다는 뜻이다.

빛을 혼합해 색을 표현하는 방식을 가산 색 시스템이라고 부른다.

감산 색 시스템에서는 주 색이 청록색, 자홍색, 노란색이다. 해당하지 않는 빛 제거하면서 색을 만들어낸다. 두 시스템 모두 모든 색을 만들 수 없지만 가산 시스템이 더 많은 색을 만들 수 있다.

현대 컴퓨터들은 색을 표현하는데 24비트를 사용해 1천만에 가장 가까운 2의 제곱수에 해당하는 색을 표현할 수 있다. 24비트는 세 가지 8비트 필드로 뉘며, 각 필드는 세 가지 주요 색을 표현한다.

24비트에 해당하는 이름이 없다. 현대 컴퓨터들이 24비트 단위로 계산을 수행하도록 설계되지 않았기 때문이다. 24비트에 가장 가까운 표준 크기인 32비트에 색을 넣어서 처리하기도 한다.

색을 표현할 때마다 사용하지 않는 비트가 8개 있다는 사실을 알 수 있다. 낭비되는 비트를 투명도를 표현하기 위해서 사용한다.
